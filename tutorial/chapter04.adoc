= 4. Контейнеры

== Списки: введение

Начиная с этого раздела мы переходим к изучению составных типов данных, включающих в себя несколько элементов простых типов.
Такие типы очень часто необходимы в программировании.
Вспомним, например, задачу про поиск минимального корня биквадратного уравнения ax^4^ + bx^2^ + c = 0 из урока 2.
В гораздо более распространённой формулировке она выглядела бы так: найти ВСЕ корни биквадратного уравнения.

Можно ли написать функцию, которая эту задачу решит?
Конечно, да, но результатом подобной функции должен быть __список__ найденных корней биквадратного уравнения.
__Список__ -- это и есть один из очень распространённых составных типов со следующими свойствами:

 * список может включать в себя произвольное количество __элементов__ (от нуля до бесконечности)
 * количество элементов в списке называется его размером
 * все элементы списка имеют один и тот же тип (в свою очередь, этот тип может быть простым -- список вещественных чисел, или составным -- список строк, или список списков целых чисел, или любые другие варианты)
 * в остальном элементы списка независимы друг от друга

Рассмотрим решение задачи о поиске корней биквадратного уравнения на Котлине:

[source,kotlin]
----
fun biRoots(a: Double, b: Double, c: Double): List<Double> {
    if (a == 0.0) {
        if (b == 0.0) return listOf()
        val bc = -c / b
        if (bc < 0.0) return listOf()
        val root = Math.sqrt(bc)
        return if (root == 0.0) listOf(root) else listOf(-root, root)
    }
    val d = discriminant(a, b, c)
    if (d < 0.0) return listOf()
    val y1 = (-b + Math.sqrt(d)) / (2 * a)
    val y2 = (-b - Math.sqrt(d)) / (2 * a)
    // part1: List<Double>
    val part1 = if (y1 < 0) listOf() else if (y1 == 0.0) listOf(0.0) else {
        val x1 = Math.sqrt(y1)
        listOf(-x1, x1)
    }
    // part2: List<Double>
    val part2 = if (y2 < 0) listOf() else if (y2 == 0.0) listOf(0.0) else {
        val x2 = Math.sqrt(y2)
        listOf(-x2, x2)
    }
    return part1 + part2
}
----

Данное решение построено по алгоритму, приведённому в конце второго урока,
с той лишь разницей, что здесь мы ищем все имеющиеся корни:

 1. Первый **if** рассматривает тривиальный случай a = 0 и более простое уравнение bx^2^ = -c. Оно либо не имеет корней (с / b > 0), либо имеет один корень 0 (c / b = 0), либо два корня (c / b < 0).
 1. Затем мы делаем замену y = x^2^ и считаем дискриминант d = b^2^ - 4ac. Если он отрицателен, уравнение не имеет корней.
 1. Если дискриминант равен 0, уравнение ay^2^ + by + c = 0 имеет один корень. В зависимости от его знака, биквадратное уравнение либо не имеет корней, либо имеет один корень 0, либо имеет два корня.
 1. В противном случае дискриминант положителен и уравнение ay^2^ + by + c = 0 имеет два корня. Каждый из них, в зависимости от его знака, превращается в ноль, один или два корней биквадратного уравнения.

Посмотрите на тип результата функции **biRoots** -- он указан как `List<Double>`.
`List` в Котлине -- это и есть список.
В угловых скобках `<>` указывается так называемый __типовой аргумент__ -- тип элементов списка,
 то есть `List<Double>` вместе -- это список вещественных чисел.

Для создания списков, удобно использовать функцию `listOf()`.
Аргументы этой функции -- это элементы создаваемого списка, их может быть произвольное количество (в том числе 0).
В ряде случаев, когда биквадратное уравнение не имеет корней, функция **biRoots* возвращает пустой список результатов.

В последнем, самом сложном случае, когда уравнение ay^2^ + by + c = 0 имеет два корня y~1~ и y~2~,
мы формируем решения уравнений x^2^ = y~1~ и x^2^ = y~2~ в виде списков part1 и part2.
Обе эти промежуточные переменные имеют тип `List<Double>` --
в этом можно убедиться в IDE, поставив на них курсор ввода и нажав комбинацию клавиш `Ctrl+Q`.
В последнем операторе **return** мы **складываем** два этих списка друг с другом: `return part1 + part2`,
образуя таким образом третий список, содержащий в себе все элементы двух предыдущих.

Функцию **biRoots** можно несколько упростить, обратив внимание на то,
что мы в ней **четыре** раза решаем одну и ту же задачу: поиск корней уравнения x^2^ = y.
Для программиста такая ситуация должна сразу превращаться в сигнал --
**следует** написать для решения этой задачи отдельную, более простую функцию:

[source,kotlin]
----
fun sqRoots(y: Double) =
        if (y < 0) listOf()
        else if (y == 0.0) listOf(0.0)
        else {
            val root = Math.sqrt(y)
            // Результат!
            listOf(-root, root)
        }
----

Посмотрите внимательнее на оператор **if..else if..else**.
Первые две его ветки формируют результат сразу же, используя **listOf()** и **listOf(0.0)**.
А вот ветка **else** вначале создаёт промежуточную переменную `root` и уже потом формирует результат **listOf(-root, root)**.
Запомните: результат ветки в таких случаях формирует **последний** её оператор.

С использованием **sqRoots** функция **biRoots** примет следующий вид:

[source,kotlin]
----
fun biRoots(a: Double, b: Double, c: Double): List<Double> {
    if (a == 0.0) {
        if (b == 0.0) return listOf()
        else return sqRoots(-c / b)
    }
    val d = discriminant(a, b, c)
    if (d < 0.0) return listOf()
    if (d == 0.0) return sqRoots(-b / (2 * a))
    val y1 = (-b + Math.sqrt(d)) / (2 * a)
    val y2 = (-b - Math.sqrt(d)) / (2 * a)
    return sqRoots(y1) + sqRoots(y2)
}
----

Из исходных 24 строчек осталось только 11, да и понимание текста функции стало существенно проще.

Напишем теперь тестовую функцию для проверки работы функции **biRoots**.
Для этой цели последовательно решим с её помощью следующие уравнения:

 * 0x^4^ + 0x^2^ + 1 = 0 (корней нет)
 * 0x^4^ + 1x^2^ + 2 = 0 (корней нет)
 * 0x^4^ + 1x^2^ - 4 = 0 (корни -2, 2)
 * 1x^4^ - 2x^2^ + 4 = 0 (корней нет)
 * 1x^4^ - 2x^2^ + 1 = 0 (корни -1, 1)
 * 1x^4^ + 3x^2^ + 2 = 0 (корней нет)
 * 1x^4^ - 5x^2^ + 4 = 0 (корни -2, -1, 1, 2)

[source,kotlin]
----
fun biRoots() {
    assertEquals(listOf<Double>(), biRoots(0.0, 0.0, 1.0))
    assertEquals(listOf<Double>(), biRoots(0.0, 1.0, 2.0))
    assertEquals(listOf(-2.0, 2.0), biRoots(0.0, 1.0, -4.0))
    assertEquals(listOf<Double>(), biRoots(1.0, -2.0, 4.0))
    assertEquals(listOf(-1.0, 1.0), biRoots(1.0, -2.0, 1.0))
    assertEquals(listOf<Double>(), biRoots(1.0, 3.0, 2.0))
    assertEquals(listOf(-2.0, -1.0, 1.0, 2.0), biRoots(1.0, -5.0, 4.0))
}
----

Обратите внимание, что здесь мы используем запись `listOf<Double>()` для создания пустого списка.
Дело в том, что для вызовов вроде `listOf(-2.0, 2.0)`
тип элементов создаваемого списка понятен из аргументов функции -- это `List<Double>`.
А вот вызов `listOf()` без аргументов не даёт никакой информации о типе элементов списка,
в то же время, например, пустой список строк и пустой список целых чисел -- с точки зрения Котлина не одно и то же.

Во многих случаях Котлин, тем не менее, может понять, о каком списке идёт речь.
Например, функция **biRoots** имеет результат `List<Double>`,
а значит, все списки, используемые в операторах **return**, должны иметь такой же тип.
Случай с вызовом `assertEquals`, однако, не несёт достаточной информации, чтобы понять тип элементов,
и мы вынуждены записать вызов функции более подробно -- `listOf<Double>()`, указывая __типовой аргумент__ `<Double>`
**между** именем вызываемой функции и списком её аргументов в круглых скобках.

Запустим теперь написанную тестовую функцию. Мы получим проваленный тест из-за последней проверки:

[source,kotlin]
----
org.opentest4j.AssertionFailedError: expected: <[-2.0, -1.0, 1.0, 2.0]> but was: <[-2.0, 2.0, -1.0, 1.0]>
----

То есть мы ожидали список корней -2, -1, 1, 2, а получили вместо этого -2, 2, -1, 1.
Дело в том, что списки в Котлине считаются равными, если совпадают их размеры, и соответствующие элементы списков равны.
Списки, состоящие из одних и тех же элементов, но на разных местах, считаются разными.

В этом месте программист должен задуматься, а что, собственно, он хочет в точности от функции **biRoots**.
Должны ли найденные корни быть упорядочены по возрастанию, или они могут присутствовать в списке в любом порядке?
Если должны, то он должен исправить функцию **biRoots**, а если нет -- то тестовую функцию,
так как она требует от тестируемой функции больше, чем та по факту даёт.

В обоих случаях нам придётся отсортировать список найденных корней перед сравнением.
В Котлине это можно сделать, вызвав функцию `.sorted()`:

[source,kotlin]
----
fun biRoots() {
    // ...                                                               v
    assertEquals(listOf(-2.0, -1.0, 1.0, 2.0), biRoots(1.0, -5.0, 4.0).sorted())
}
----

В уроке 3 мы уже встречались с функциями с __получателем__ `.toInt()` и `.toDouble()`.
Функция `.sorted()` также требует наличия получателя: вызов `list.sorted()` создаёт список того же размера,
что и исходный, но его элементы будут упорядочены по возрастанию.

== Распространённые операции над списками

Перечислим некоторые операции над списками, имеющиеся в библиотеке языка Котлин:

 1. `listOf(...)` -- создание нового списка.
 1. `list1 + list2` -- сложение двух списков.
 1. `list.size` -- получение размера списка (Int).
 1. `list.isEmpty()`, `list.isNotEmpty()` -- получение признаков пустоты и непустоты списка (Boolean).
 1. `list[i]` -- индексация, то есть получение __элемента__ списка с целочисленным __индексом__ (номером) `i`. По правилам Котлина, в списке из `n` элементов они имеют индексы, начинающиеся с нуля: 0, 1, 2, ..., последний элемент списка имеет индекс `n - 1`. То есть, при использовании записи `list[i]` должно быть справедливо `i >= 0 && i < list.size`. В противном случае выполнение программы будет прервано с ошибкой (использование индекса за пределами границ списка).
 1. `list.sublist(from, to)` -- создание списка меньшего размера (подсписка), в который войдут элементы списка `list` с индексами `from`, `from + 1`, ..., `to - 2`, `to - 1`. Элемент с индексом `to` не включается.
 1. `element in list` -- проверка принадлежности элемента `element` списку `list`.
 1. `for (element in list) { ... }` -- цикл **for**, перебирающий все элементы списка `list`.
 1. `list.first()` -- получение первого элемента списка (если список пуст, выполнение программы будет прервано с ошибкой)
 1. `list.last()` -- получение последнего элемента списка (аналогично).
 1. `list.sorted()`, `list.sortedDescending()` -- построение отсортированного списка (по возрастанию или по убыванию) из имеющегося.
