= Дополнительные главы

== Разбор и представление арифметических выражений

Эта глава развивает содержимое пятого урока,
отвечая на вопрос "А что делать, если простого разбиения строки на части недостаточно?".
Одной из подобных ситуаций является разбор арифметических выражений.
Для этого и других похожих случаев программисты придумали парсеры --
специальные функции или объекты, выполняющие разбор сложных строк.
Для написания парсеров используется теория формальных языков,
которой мы (вкратце) коснёмся в этой главе.

Рассмотрим пример.
Пусть во входном файле содержится строчка, содержащая описание функции от `x`, например:

[source]
----
3*x*x - (2 / x)  + 7 -x
----

Необходимо по имеющемуся списку значений `x` (например, 1, 2 и -1)
рассчитать значение данной функции и вернуть их в виде ассоциативного массива
(например, 1 -> 7, 2 -> 16, -1 -> 13).

Предполагается, что функция является целочисленной,
и в ней могут присутствовать четыре арифметических действия и круглые скобки.

Как решать подобную задачу? Поэтапно.

=== 1. Лексический анализ

Лексический анализ -- первый этап решения.
Его цель -- разбиение исходного выражения на атомарные элементы,
которыми в приведённом примере являются:

[source]
----
3, *, x, *, x, -, (, 2, /, x, ), +, 7, -, x
----

Обратите внимание, что в процессе лексического анализа из выражения выбрасываются пробелы.

Один из способов лексического анализа -- применение регулярных выражений.

[source,kotlin]
----
fun String.parseExpr(): Expression {
    val matchResults = Regex("""x|\+|-|\*|/|\(|\)|\d+?| +?|.+?""").findAll(this)
    val groups = matchResults.map { it.value }.filter { it.isNotBlank() }.toList()
    return Parser(groups).parse()
}
----

Заданное в этой функции регулярное выражение задаёт описание атомарного элемента.
Это может быть `x`, знаки четырёх арифметических действий, знаки скобок,
пробелы, и все прочие символы.
Лямбда `{ it.isNotBlank() }` убирает из имеющейся последовательности пробелы,
оставляя всё остальное.
После этого происходит переход к следующему этапу -- собственно разбору.
Но перед этим поговорим о том, а что, собственно, мы хотим получить в результате разбора.

=== 1.5. Представление выражений

Зададимся вопросом: как представить арифметическое выражение
с помощью структур данных, имеющихся в Котлине?
Перед ответом на этот вопрос стоит ответить на другой:
а что такое (формально) арифметическое выражение в нашей задаче?
В теории формальных языков ответ может выглядеть так:

* это `x`,
* или же, это целая константа,
* или же, это операция (сложение / вычитание / умножение / деление) над двумя другими выражениями

[source,kotlin]
----
sealed class Expression {
    object Variable : Expression()

    class Constant(val value: Int) : Expression()

    enum class Operation {
        PLUS,
        MINUS,
        TIMES,
        DIV;
    }

    class Binary(
            val left: Expression,
            val op: Operation,
            val right: Expression
    ) : Expression()

    class Negate(val arg: Expression) : Expression()
----

=== 2. Синтаксический анализ

Этот этап иногда называется просто "разбор".
