= 5. Ассоциативные массивы aka Maps и множества aka Sets

== Введение

В прошлом уроке мы познакомились с вами с различными структурами данных, которые предназначены для хранения упорядоченной последовательности элементов.
Понятно, что это далеко не единственный тип структур данных, которые существуют, и сегодня мы с вами познакомимся с двумя новыми структурами данных.

Чтобы понять первую структуру данных --- **ассоциативный массив** --- далеко ходить не надо, достаточно вспомнить о такой штуке как толковый словарь.
Он связывает элементы отношением "ключ" - "значение": для определенных слов ("ключей") он содержит их описание ("значения"), для всех остальных --- не содержит ничего.
Подобной структурой обладают, на самом деле, многие вещи: набор товаров с их ценами, список контактов в телефоне, рестораны и рейтинги, и т.д.

Ассоциативный массив является обобщенным способом представить подобное отношение.
Давайте на следующем примере посмотрим, как с ним можно работать.
Представим, что нам необходимо посчитать стоимость нашего списка покупок для заданного набора товаров.
Сделать это можно при помощи следующей функции.

[source,kotlin]
----
fun shoppingListCost(
        shoppingList: List<String>,
        costs: Map<String, Double>): Double {
    var totalCost = 0.0

    for (item in shoppingList) {
        val itemCost = costs[item]
        if (itemCost != null) {
            totalCost += itemCost
        }
    }

    return totalCost
}
----

Что мы здесь видим?
Наша функция принимает на вход список покупок: параметр `shoppingList` типа `List<String>` --- и набор цен для товаров: параметр `costs` типа `Map<String, Double>`.
Данный параметризованный тип `Map<Key, Value>` и является типом ассоциативного массива, у которого типовой параметр `Key` задает тип ключей, а `Value` --- тип значений.
В нашем случае набор товаров с ценами имеет тип `Map<String, Double>`, т.е. для названия товара содержит его цену в виде действительного числа.

Для того, чтобы считать общую стоимость выбранного набора товаров, мы заводим новую изменяемую переменную `totalCost`, которая изначально равна нулю и которую мы возвращаем как результат в конце функции при помощи `return`.
После этого мы проходимся по списку покупок при помощи цикла `for` и для каждой покупки пытаемся достать ее цену из нашего ассоциативного массива при помощи операции индексирования.
В отличии от индексирования для списка, операция индексирования `map[key]` для ассоциативного массива пытается достать элемент не по какому-либо целочисленному индексу, а по ключу соответствующего типа --- в нашем случае, по названию товара, т.е. строке.

А вот дальше мы знакомимся с такой очень интересной вещью как `null`.
Как мы отметили раньше, ассоциативный массив содержит пары "ключ"-"значение", однако для некоторых ключей соответствующего им значения может не быть.
Вместе с тем, просто так вернуть *"ничего"* мы не можем.
Как раз для таких ситуаций и необходим объект `null` --- операция индексирования для ассоциативного массива возвращает `null` в случае, если для заданного ключа нет значения. После того, как мы проверили, что для товара есть его стоимость (`itemCost != null`), мы добавляем ее к общей стоимости набора; в противном случае мы считаем, что данная покупка просто игнорируется.

Попробуем написать тесты для нашей функции.

[source,kotlin]
----
@Test
fun shoppingListCostTest() {
    val itemCosts = mapOf(
            "Хлеб" to 50.0,
            "Молоко" to 100.0
    )
    assertEquals(
            150.0,
            shoppingListCost(
                    listOf("Хлеб", "Молоко"),
                    itemCosts
            )
    )
    assertEquals(
            150.0,
            shoppingListCost(
                    listOf("Хлеб", "Молоко", "Кефир"),
                    itemCosts
            )
    )
    assertEquals(
            0.0,
            shoppingListCost(
                    listOf("Хлеб", "Молоко", "Кефир"),
                    mapOf()
            )
    )
}
----

Как видно из тестов, для **создания** ассоциативного массива может использоваться функция `mapOf()`, которая принимает на вход список **пар** "ключ"-"значение" типа `Pair<A, B>` (в нашем случае, `Pair<String, Double>`).
Для создания пары можно использовать либо конструкцию `Pair(a, b)`, либо запись `a to b`, обе из которых создадут пару из `a` и `b`.
Для того, чтобы обратиться к первому или второму элементу пары `pair` следует использовать запись `pair.first` или `pair.second` соответственно.

В нашем случае мы создаем пары из названия товара и его стоимости, после чего собираем из них ассоциативный массив.

TODO(...)

== Распространённые операции над ассоциативными массивами

== Изменяемый ассоциативный массив

== Множества

== Распространенные операции над множествами

== Операции над `null`

== Упражнения

Откройте файл `srс/lesson5/task1/Map.kt` в проекте `KotlinAsFirst`.
Выберите любую из задач в нём.
Придумайте её решение и запишите его в теле соответствующей функции.

Откройте файл `test/lesson5/task1/Tests.kt`, найдите в нём тестовую функцию -- её название должно совпадать с названием написанной вами функции.
Запустите тестирование, в случае обнаружения ошибок исправьте их и добейтесь прохождения теста.
Подумайте, все ли необходимые проверки включены в состав тестовой функции, добавьте в неё недостающие проверки.

TODO(Написать про сами задачки)

Переходите к следующему разделу.
