= 6.5. Графы

Граф -- это математическая абстракция, имеющая, тем не менее, очень широкое применение в программировании.
Граф состоит из множества так называемых __вершин__, которые обычно изображаются как точки на плоскости,
и __рёбер__ (другое название ребра -- __дуга__), которые эти вершины соединяют.
Пример графа приведён на рисунке (TODO).

Чаще всего графы применяются для описания различных схем, например, 
соединения узлов в компьютерной сети или городов и других пунктов на карте местности.
Типичная решаемая с помощью графа задача -- поиск кратчайшего маршрута из одного пункта в другой.
Довольно часто граф, помимо информации о своих вершин и рёбрах, содержит вспомогательную информацию.
Например, для схемы дорог ей могут быть названия городов, соответствующих вершинам графа,
или длины дорог, соответствующих рёбрам графа. Пример (TODO):

Структуры данных, __подобные__ графам, могут возникать в различных задач поиска оптимального решения.
Например, в `lesson6/task2` имеется задача о поиске наиболее короткой траектории движения шахматного коня.
Эту задачу можно описать с помощью графа, вершинами которого являются клетки шахматной доски,
а рёбра соединяют те из них, между которыми может двигаться шахматный конь.
Для фрагмента шахматной доски граф может выглядеть примерно так (TODO):

Описать граф на языке программирования можно разными способами.
В той же задаче о маршруте шахматного коня лучше вообще не хранить информацию о вершинах графа,
достаточно лишь уметь по конкретной клетке найти связанные с ней ребром --
то есть, те клетки, в которые из данной клетки может прыгнуть конь.
В других задачах, тем не менее, информацию о вершинах и рёбрах графа есть смысл сохранить,
и тогда следует для этой цели использовать собственный __класс__.
Пример реализации такого класса приведён ниже.

[source,kotlin]
----
class Graph {
    private data class Vertex(val name: String) {
        val neighbors = mutableSetOf<Vertex>()
    }

    private val vertices = mutableMapOf<String, Vertex>()

    private operator fun get(name: String) = vertices[name] ?: throw IllegalArgumentException()

    fun addVertex(name: String) {
        vertices[name] = Vertex(name)
    }

    private fun connect(first: Vertex, second: Vertex) {
        first.neighbors.add(second)
        second.neighbors.add(first)
    }

    fun connect(first: String, second: String) = connect(this[first], this[second])

    fun neighbors(name: String) = vertices[name]?.neighbors?.map { it.name } ?: listOf()
}
----

Описанный здесь `Graph` является довольно сложным классом.
Он включает в себя функцию `addVertex` (добавить вершину) и две функции `connect` (соединить) с разным набором параметров,
причём одна из них является __закрытой__ (private).
Для доступа к списку вершин, соседних для данной, в классе имеется функция `neighbors`,
Кроме этого, в классе имеется __операторная__ функция `get`, которая также является закрытой,
__свойство__ (val) `vertices` (вершины), которое опять-таки закрыто, 
и __вложенный__ класс `Vertex` (вершина) со свойствами `name` (имя) и `neighbors` (соседи).
Рассмотрим все эти элементы класса `Graph` подробнее.

== Члены класса

Класс может иметь произвольное количество членов (members), которые делятся на две категории: __свойства__ и __функции__.
Свойства класса определяются как **val** (неизменяемые) или **var** (изменяемые).
Чаще всего они используются для описания внутренней структуры класса;
например, в классе `Graph` свойство `vertices` используется для сохранения информации о вершинах графа,
а в классе `Vertex` свойство `neighbors` сохраняет информацию о вершинах,
соседних (то есть соединённых ребром) с данной.

Функции класса определяются как **fun** и используются для различных операций с объектом данного класса,
в данном случае -- с графом. В данном случае, функции `connect` служат для соединения двух вершин графа ребром --
то есть, для добавления в граф нового ребра. Функция `addVertex` добавляет в граф новую вершину.

== Видимость

Члены класса могут иметь различную __видимость__.
Чаще всего в Котлине используются два уровня видимости: открытый (public, по умолчанию) и закрытый (private).
Для изменения уровня видимости следует указать ключевое слово **public** или **private** перед определением члена класса.

Открытые члены класса могут использоваться всеми.
В любой части программы мы имеем право написать `graph.connect(...)` для добавления в граф нового ребра.
Закрытые члены класса могут использоваться только самим классом;
при попытке написать `graph.vertices` снаружи класса для обращения к свойству `vertices`
произойдёт ошибка при компиляции программы.

Закрытые члены класса были придуманы программистами, чтобы разграничить ответственность за разные участки программы.
Действует следующий принцип: каждый класс сам отвечает за своё содержимое.
В идеале, никакие операции с открытыми членами класса не должны приводить к ошибкам,
и состояние объекта класса должно меняться в соответствии с выполненными операциями. Например:

[source,kotlin]
----
fun useGraph() {
    val g = Graph()
    g.addVertex("A")
    g.addVertex("B")
    g.addVertex("C")
    g.addVertex("D")
    g.connect("A", "C")
    g.connect("B", "D")
    g.connect("B", "C")
}
// Должен получиться граф
// A ----- C
//         |
//         |
// D ----- B
----

Программист, написавший функцию `useGraph`, резонно ожидает, что после выполнения приведённого кода
в графе `g` будет четыре вершины и три ребра, выглядяющих примерно так, как изображено в комментарии.

