= 6.5. Графы

Граф -- это математическая абстракция, имеющая, тем не менее, очень широкое применение в программировании.
Граф состоит из множества так называемых __вершин__, которые обычно изображаются как точки на плоскости,
и __рёбер__ (другое название ребра -- __дуга__), которые эти вершины соединяют.
Пример графа приведён на рисунке (TODO).

Чаще всего графы применяются для описания различных схем, например, 
соединения узлов в компьютерной сети или городов и других пунктов на карте местности.
Типичная решаемая с помощью графа задача -- поиск кратчайшего маршрута из одного пункта в другой.
Довольно часто граф, помимо информации о своих вершин и рёбрах, содержит вспомогательную информацию.
Например, для схемы дорог ей могут быть названия городов, соответствующих вершинам графа,
или длины дорог, соответствующих рёбрам графа. Пример (TODO):

Структуры данных, __подобные__ графам, могут возникать в различных задач поиска оптимального решения.
Например, в `lesson6/task2` имеется задача о поиске наиболее короткой траектории движения шахматного коня.
Эту задачу можно описать с помощью графа, вершинами которого являются клетки шахматной доски,
а рёбра соединяют те из них, между которыми может двигаться шахматный конь.
Для фрагмента шахматной доски граф может выглядеть примерно так (TODO):

Описать граф на языке программирования можно разными способами.
В той же задаче о маршруте шахматного коня лучше вообще не хранить информацию о вершинах графа,
достаточно лишь уметь по конкретной клетке найти связанные с ней ребром --
то есть, те клетки, в которые из данной клетки может прыгнуть конь.
В других задачах, тем не менее, информацию о вершинах и рёбрах графа есть смысл сохранить,
и тогда следует для этой цели использовать собственный __класс__.
Пример реализации такого класса приведён ниже.

[source,kotlin]
----
class Graph {
    private data class Vertex(val name: String) {
        val neighbors = mutableSetOf<Vertex>()
    }

    private val vertices = mutableMapOf<String, Vertex>()

    private operator fun get(name: String) = vertices[name] ?: throw IllegalArgumentException()

    fun addVertex(name: String) {
        vertices[name] = Vertex(name)
    }

    private fun connect(first: Vertex, second: Vertex) {
        first.neighbors.add(second)
        second.neighbors.add(first)
    }

    fun connect(first: String, second: String) = connect(this[first], this[second])

    fun neighbors(name: String) = vertices[name]?.neighbors?.map { it.name } ?: listOf()
}
----

Описанный здесь `Graph` является довольно сложным классом.
Он включает в себя функцию `addVertex` (добавить вершину) и две функции `connect` (соединить) с разным набором параметров,
причём одна из них является __закрытой__ (private).
Для доступа к списку вершин, соседних для данной, в классе имеется функция `neighbors`,
Кроме этого, в классе имеется __операторная__ функция `get`, которая также является закрытой,
__свойство__ (val) `vertices` (вершины), в котором хранится ассоциативный массив (MutableMap) и которое опять-таки закрыто,
и __вложенный__ класс `Vertex` (вершина) со свойствами `name` (имя) и `neighbors` (соседи).
Рассмотрим все эти элементы класса `Graph` подробнее.

== Члены класса

Класс может иметь произвольное количество членов (members), которые делятся на две категории: __свойства__ и __функции__.
Свойства класса определяются как **val** (неизменяемые) или **var** (изменяемые).
Чаще всего они используются для описания внутренней структуры класса;
например, в классе `Graph` свойство `vertices` используется для сохранения информации о вершинах графа,
а в классе `Vertex` свойство `neighbors` сохраняет информацию о вершинах,
соседних (то есть соединённых ребром) с данной.

Функции класса определяются как **fun** и используются для различных операций с объектом данного класса,
в данном случае -- с графом. В данном случае, функции `connect` служат для соединения двух вершин графа ребром --
то есть, для добавления в граф нового ребра. Функция `addVertex` добавляет в граф новую вершину.

== Видимость

Члены класса могут иметь различную __видимость__.
Чаще всего в Котлине используются два уровня видимости: открытый (public, по умолчанию) и закрытый (private).
Для изменения уровня видимости следует указать ключевое слово **public** или **private** перед определением члена класса.

Открытые члены класса могут использоваться всеми.
В любой части программы мы имеем право написать `graph.connect(...)` для добавления в граф нового ребра.
Закрытые члены класса могут использоваться только самим классом;
при попытке написать `graph.vertices` снаружи класса для обращения к свойству `vertices`
произойдёт ошибка при компиляции программы.

Закрытые члены класса были придуманы программистами, чтобы разграничить ответственность за разные участки программы.
Действует следующий принцип: каждый класс сам отвечает за своё содержимое.
В идеале, никакие операции с открытыми членами класса не должны приводить к ошибкам,
и состояние объекта класса должно меняться в соответствии с выполненными операциями. Например:

[source,kotlin]
----
fun useGraph() {
    val g = Graph()
    g.addVertex("A")
    g.addVertex("B")
    g.addVertex("C")
    g.addVertex("D")
    g.connect("A", "C")
    g.connect("B", "D")
    g.connect("B", "C")
    println(g.neighbors("B"))
}
// Должен получиться граф
// A ----- C
//         |
//         |
// D ----- B
// println выведет: ["C", "B"]
----

Программист, написавший функцию `useGraph`, резонно ожидает, что после выполнения приведённого кода
в графе `g` будет четыре вершины и три ребра, выглядяющих примерно так, как изображено в комментарии.
Он также ожидает, что при поиске вершин, соседних с "B", мы получим список из вершин "C" и "D".
При этом ассоциативный массив `vertices` (который фактически и хранит информацию о вершинах графа),
является закрытым и его не может изменять никто, кроме других членов данного класса.

Использованный здесь принцип программисты называют __инкапсуляцией__.
Граф в данном случае подобен капсуле, на которой есть кнопки "addVertex" и "connect" (их нажатие изменяет граф),
а также индикатор `neighbors` (вызов соответствующей функции не изменяет граф).
Всё остальное находится внутри капсулы и не видно снаружи;
закрытое содержимое графа является его личным (приватным) делом.

== Вложенные классы

Довольно часто бывает так, что некоторый класс не имеет смысла без какого-то другого класса.
Так произошло и в нашем примере -- вершина не имеет никакого смысла без графа.
В этом случае класс `Vertex`, соответствующий вершине, определяется **внутри** класса `Graph`.
Поскольку в данном случае класс закрытый, то и использоваться он может
только внутри класса `Graph`.
Если бы класс `Vertex` был открыт, его можно было бы использовать снаружи графа как `Graph.Vertex`.

В данном случае вершина имеет свойство "имя" (name), которое задаётся в её конструкторе,
и свойство "соседи" (neighbors), которое хранит мутирующее __множество__ (MutableSet) из других вершин.
При создании вершины множество её соседей пусто, но вызовы функции `connect` из графа расширяют его.

== Множества и списки

Множества во многих отношениях похожи на списки, но всё же отличаются от них.
Множества, как и списки, содержат внутри себя некоторое количество однотипных элементов;
отличие от списков состоит в том, что множество не может содержать одинаковых элементов.
При попытке добавить в множество элемент, который там уже есть, множество не изменяется.

Для множества имеется возможность проверить наличие в нём определённого элемента,
или же перебрать все элементы множества с помощью цикла **for** -- обе эти возможности есть и у списков.
Для множества имеется свойство `size` и функции `isEmpty()`, `isNotEmpty()` для определения его размера.
Множества можно складывать друг с другом -- все перечисленные операции у списков тоже имеются.
Множества в Котлине бывают обычными `Set<T>` либо мутирующими `MutableSet<T>`.

Является ли множество просто списком, в котором нет одинаковых элементов? Нет, это не так.
Множество не поддерживает доступ по индексу, то есть в нём отсутствует операция `set[i]` --
как для чтения, так и для записи.
Зато множество умеет значительно быстрее списка определять наличие в нём элементов `element in set`.
Для реализации этой операции над списком необходимо перебрать его весь,
а множества имеют более сложную структуру, позволяющую находить элементы в нём быстрее.

Создаются множества в Котлине с помощью функций `setOf(...)` и `mutableSetOf(...)`.

== Коллекции

__Коллекция__ является так называемым надтипом как множества, так и списка.
Коллекция объединяет их общие свойства и возможности.
Список, помимо возможностей коллекции, имеет возможность индексирования.
Множество, помимо возможностей коллекции, не добавляет в себя уже имеющиеся элементы.

Коллекция `Collection<T>` хранит в себе однотипные элементы типа `T`.
Возможностями коллекции являются:

 1. Определение количества элементов (размера), пустоты, непустоты.
 1. Определение вхождения элемента и перебор элементов (in).
 1. Сложение с другой коллекцией или с отдельным элементом.
 1. Для мутирующей коллекции `MutableCollection<T>`, также -- добавление и удаление элемента.

Коллекции используются в ситуации, когда программисту безразличен конкретный вид коллекции.
В частности, многие операции, уже привычные нам для списков, на самом деле определены для коллекций.

== Ассоциативные массивы

__Ассоциативный массив__ (он же -- карта или словарь) `Map<K, V>` подобен обычному массиву или, вернее, списку.
Разница заключается в том, что индексом в списке является целое число от 0 до `list.size - 1`,
а индексом в ассоциативном массиве может быть всё что угодно.
Тип используемого индекса (ключа) определяется параметром карты `K`, а тип хранимых значений -- параметром `V`.
Для массива `vertices`, ключом является строка `String` (имя вершины), а значением -- сама вершина `Vertex`.