= 2. Ветвления

До этого мы рассматривали ситуации, когда вычисление результата функций происходило без рассмотрения вариантов.
Это возможный, но сравнительно редкий случай в программировании.
Существует очень много задач, где приходится рассматривать различные варианты,
и для этой цели программисты придумали __ветвления__.

В качестве простого примера рассмотрим функцию, результат которой равен наибольшему из её параметров.

[source,kotlin]
----
fun max(m: Int, n: Int) = if (m > n) m else n
----

Здесь **if..else** -- __оператор__ или __конструкция__ ветвления, переводится с английского как **если..иначе**.
После ключевого слова **if** в скобках следует __условие__ ветвления **m > n**.
Если условие __истинно__, в качестве результата используется выражение сразу за условием ветвления, в данном случае **m**.
Если же условие __ложно__, используется выражение за ключевым словом **else**, в данном случае **n**.
Конструкцию можно прочитать по-русски как "Если m > n, (то) m, иначе n".

Рассмотрим более сложный пример.
Следующая функция рассчитывает __число__ корней квадратного уравнения ax^2^ + bx + c = 0.
Напомним, что квадратное уравнение имеет два корня, если его дискриминант больше 0,
один корень, если дискриминант раван 0, и ноль корней в противном случае.
Для реализации этого алгоритма следует вначале рассчитать дискриминант,
а затем применить конструкцию **if..else**.
Функция на Котлине может быть записана так:

[source,kotlin]
----
fun quadraticRootNumber(a: Double, b: Double, c: Double): Int {
    // Применяем готовую функцию из первой части
    val d = discriminant(a, b, c)
    // Для сравнения на равенство применяем ==
    return if (d > 0.0) 2 else if (d == 0.0) 1 else 0
}
----

Здесь мы применили запись функции в виде блока и использовали промежуточную переменную d.
Последняя строчка функции читается как "вернуть: если d > 0.0, (то) 2, иначе, если d = 0.0, (то) 1, иначе 0".
Обратите внимание на возможность так называемой "каскадной" записи конструкции **if..else**
в виде **if..else if..else if..else if..else** (с неограниченным количеством промежуточных элементов).

В обоих примерах в условиях мы использовали __операции сравнения__. Таких операций имеется шесть:

 * > строго больше
 * >= больше или равно
 * < строго меньше
 * &lt;= меньше или равно
 * != не равно
 * == равно (используется два знака равенства, чтобы не путать данную операцию с инициализацией / вычислением результата =)

Операции == и != в Котлине применимы для сравнения аргументов произвольных типов.
В частности, разрешается сравнивать на равенство строки --
они равны, если имеют равную длину, и соответствующие их символы совпадают: "abc" != "cba".

Остальные четыре операции применимы только в том случае,
если для аргументов определена специальная функция сравнения **compareTo** -- об этом мы будем говорить позже.
Первое время, нам придётся применять их только для числовых типов.

Математически, результат всех операций сравнения имеет тип **Boolean** с ровно двумя возможными значениями: **true**, **false**.

Каскадную запись **if..else if..else** часто можно представить более изящно в табличной форме, используя конструкцию **when** (когда).
Для примера **quadraticRootNumber** это делается так:

[source,kotlin]
----
fun quadraticRootNumber(a: Double, b: Double, c: Double): Int {
    // Применяем готовую функцию из первой части
    val d = discriminant(a, b, c)
    // Для сравнения на равенство применяем ==
    return when {
        d > 0.0  -> 2
        d == 0.0 -> 1
        else     -> 0
    }
}
----

Конструкция **when** состоит из последовательности **записей** вида ``условие -&gt; результат``.
В последней записи условие заменяется на ключевое слово **else** (иначе).

Частый случай применения **when** -- ситуация, когда одно и то же выражение необходимо
последовательно сравнить с несколькими другими.
Для примера, рассмотрим задачу формирования словесной нотации для оценки.
Согласно принятым сейчас стандартам, оценка "5" записывается как "отлично", "4" как "хорошо",
"3" как "удовлетворительно" и "2" как "неудовлетворительно".
Представим подобное преобразование в виде функции на Котлине, используя **when**:

[source,kotlin]
----
fun gradeNotation(grade: Int): String = when (grade) {
    5 -> "отлично"
    4 -> "хорошо"
    3 -> "удовлетворительно"
    2 -> "неудовлетворительно"
    else -> "несуществующая оценка $grade"
}
----

Эта функция принимает на вход целочисленную оценку (grade) и формирует на выходе соответствующую ей строку.
Напомним, что строкам в Котлине соответствует тип **String** и записываются они в двойных кавычках.
Обратите внимание, что, помимо четырёх приведённых выше случаев (5, 4, 3, 2),
в нашей записи **when** добавился пятый случай (else).
Его присутствие необходимо, так как функция должна знать, какой результат ей следует вернуть,
для любого допустимого значения входа (в данном случае это тип **Int** с его диапазоном допустимых значений).
Строго говоря, ветка **else** здесь соответствует ошибочной ситуации,
которая может предусматривать специальную обработку -- но об этом позже.
В функции **gradeNotation** в этой ситуации мы формируем строку "несуществующая оценка",
дописывая к ней значение переданной оценки, например: "несуществующая оценка 0".

== Упражнения

Откройте файл `srс/lesson2/task1/IfElse.kt` в проекте `KotlinAsFirst`.
Выберите любую из задач в нём. Придумайте её решение и запишите его.
Откройте файл `test/lesson2/task1/Tests.kt`,
найдите в нём тестовую функцию -- её название должно совпадать с названием написанной вами функции.
Щёлкните мышью на зелёный значок запуска теста, в нижней части окна IDEA появится окно тестирования.
Если задача решена верно, вы увидите в этом окне зелёную надпись All Tests Passed,
в противном случае -- 1 test failed с описанием возникшей проблемы.
Исправьте все ошибки и добейтесь прохождения теста.

Решите несколько других задач из того же файла, пока не убедитесь в том, что можете их решать уверенно
и без посторонней помощи. После этого вы можете перейти к следующему разделу.
