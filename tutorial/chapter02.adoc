= 2. Ветвления

До этого мы рассматривали ситуации, когда вычисление результата функций происходило без рассмотрения вариантов.
Это возможный, но сравнительно редкий случай в программировании.
Существует очень много задач, где приходится рассматривать различные варианты,
и для этой цели программисты придумали __ветвления__.

В качестве простого примера рассмотрим функцию, результат которой равен наибольшему из её параметров.

[source,kotlin]
----
fun max(m: Int, n: Int) = if (m > n) m else n
----

Здесь **if..else** -- __оператор__ или __конструкция__ ветвления, переводится с английского как **если..иначе**.
После ключевого слова **if** в скобках следует __условие__ ветвления **m > n**.
Если условие __истинно__, в качестве результата используется выражение сразу за условием ветвления, в данном случае **m**.
Если же условие __ложно__, используется выражение за ключевым словом **else**, в данном случае **n**.
Конструкцию можно прочитать по-русски как "Если m > n, (то) m, иначе n".

Рассмотрим более сложный пример.
Следующая функция рассчитывает __число__ корней квадратного уравнения ax^2^ + bx + c = 0.
Напомним, что квадратное уравнение имеет два корня, если его дискриминант больше 0,
один корень, если дискриминант раван 0, и ноль корней в противном случае.
Для реализации этого алгоритма следует вначале рассчитать дискриминант,
а затем применить конструкцию **if..else**.
Функция на Котлине может быть записана так:

[source,kotlin]
----
fun quadraticRootNumber(a: Double, b: Double, c: Double): Int {
    // Применяем готовую функцию из первой части
    val d = discriminant(a, b, c)
    // Для сравнения на равенство применяем ==
    return if (d > 0.0) 2 else if (d == 0.0) 1 else 0
}
----

Здесь мы применили запись функции в виде блока и использовали промежуточную переменную d.
Последняя строчка функции читается как "вернуть: если d > 0.0, (то) 2, иначе, если d = 0.0, (то) 1, иначе 0".
Обратите внимание на возможность так называемой "каскадной" записи конструкции **if..else**
в виде **if..else if..else if..else if..else** (с неограниченным количеством промежуточных элементов).

Каскадную запись часто можно представить более изящно в табличной форме, используя конструкцию **when** (когда).
Для данного примера это делается так:

[source,kotlin]
----
fun quadraticRootNumber(a: Double, b: Double, c: Double): Int {
    // Применяем готовую функцию из первой части
    val d = discriminant(a, b, c)
    // Для сравнения на равенство применяем ==
    return when {
        d > 0.0  -> 2
        d == 0.0 -> 1
        else     -> 0
    }
}
----

Конструкция **when** состоит из последовательности **записей** вида ``условие -&gt; результат``.
В последней записи условие заменяется на ключевое слово **else** (иначе).

В обоих примерах в условиях мы использовали __операции сравнения__. Таких операций имеется шесть:

 * > строго больше
 * >= больше или равно
 * < строго меньше
 * &lt;= меньше или равно
 * != не равно
 * == равно (используется два знака равенства, чтобы не путать данную операцию с инициализацией / вычислением результата =)

Операции == и != в Котлине применимы для сравнения аргументов произвольных типов.
В частности, разрешается сравнивать на равенство строки --
они равны, если имеют равную длину, и соответствующие их символы совпадают: "abc" != "cba".

Остальные четыре операции применимы только в том случае,
если для аргументов определена специальная функция сравнения **compareTo** -- об этом мы будем говорить позже.
Первое время, нам придётся применять их только для числовых типов.

Математически, результат всех операций сравнения имеет тип **Boolean** с ровно двумя возможными значениями: **true**, **false**.