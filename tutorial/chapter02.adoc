= 2. Ветвления

До этого мы рассматривали ситуации, когда вычисление результата функций происходило без рассмотрения вариантов.
Это возможный, но сравнительно редкий случай в программировании.
Существует очень много задач, где приходится рассматривать различные варианты,
и для этой цели программисты придумали __ветвления__.

В качестве простого примера рассмотрим функцию, результат которой равен наибольшему из её параметров.

[source,kotlin]
----
fun max(m: Int, n: Int) = if (m > n) m else n
----

Здесь **if..else** -- __оператор__ или __конструкция__ ветвления, переводится с английского как **если..иначе**.
После ключевого слова **if** в скобках следует __условие__ ветвления **m > n**.
Если условие __истинно__, в качестве результата используется выражение сразу за условием ветвления, в данном случае **m**.
Если же условие __ложно__, используется выражение за ключевым словом **else**, в данном случае **n**.
Конструкцию можно прочитать по-русски как "Если m > n, (то) m, иначе n".

Рассмотрим более сложный пример.
Следующая функция рассчитывает __число__ корней квадратного уравнения ax^2^ + bx + c = 0.
Напомним, что квадратное уравнение имеет два корня, если его дискриминант больше 0,
один корень, если дискриминант равен 0, и ноль корней в противном случае.
Для реализации этого алгоритма следует вначале рассчитать дискриминант,
а затем применить конструкцию **if..else**.
Функция на Котлине может быть записана так:

[source,kotlin]
----
fun quadraticRootNumber(a: Double, b: Double, c: Double): Int {
    // Применяем готовую функцию из первой части
    val d = discriminant(a, b, c)
    // Для сравнения на равенство применяем ==
    return if (d > 0.0) 2 else if (d == 0.0) 1 else 0
}
----

Здесь мы применили запись функции в виде блока и использовали промежуточную переменную d.
Последняя строчка функции читается как "вернуть: если d > 0.0, (то) 2, иначе, если d = 0.0, (то) 1, иначе 0".
Обратите внимание на возможность так называемой "каскадной" записи конструкции **if..else**
в виде **if..else if..else if..else if..else** (с неограниченным количеством промежуточных элементов).

В обоих примерах в условиях мы использовали __операции сравнения__. Таких операций имеется шесть:

 * > строго больше
 * >= больше или равно
 * < строго меньше
 * &lt;= меньше или равно
 * != не равно
 * == равно (используется два знака равенства, чтобы не путать данную операцию с инициализацией / вычислением результата =)

Операции == и != в Котлине применимы для сравнения аргументов произвольных типов.
В частности, разрешается сравнивать на равенство строки --
они равны, если имеют равную длину, и соответствующие их символы совпадают: "abc" != "cba".

Остальные четыре операции применимы только в том случае,
если для аргументов определена специальная функция сравнения **compareTo** -- об этом мы будем говорить позже.
Первое время, нам придётся применять их только для числовых типов.

Математически, результат всех операций сравнения имеет тип **Boolean** с ровно двумя возможными значениями: **true**, **false**.

Каскадную запись **if..else if..else** часто можно представить более изящно в табличной форме, используя конструкцию **when** (когда).
Для примера **quadraticRootNumber** это делается так:

[source,kotlin]
----
fun quadraticRootNumber(a: Double, b: Double, c: Double): Int {
    // Применяем готовую функцию из первой части
    val d = discriminant(a, b, c)
    // Для сравнения на равенство применяем ==
    return when {
        d > 0.0  -> 2
        d == 0.0 -> 1
        else     -> 0
    }
}
----

Конструкция **when** состоит из последовательности **записей** вида ``условие -&gt; результат``.
В последней записи условие заменяется на ключевое слово **else** (иначе).

Частый случай применения **when** -- ситуация, когда одно и то же выражение необходимо
последовательно сравнить на равенство с несколькими другими.
Для примера, рассмотрим задачу формирования словесной нотации для оценки.
Согласно принятым сейчас стандартам, оценка "5" записывается как "отлично", "4" как "хорошо",
"3" как "удовлетворительно" и "2" как "неудовлетворительно".
Представим подобное преобразование в виде функции на Котлине, используя **when**:

[source,kotlin]
----
fun gradeNotation(grade: Int): String = when (grade) {
    5 -> "отлично"
    4 -> "хорошо"
    3 -> "удовлетворительно"
    2 -> "неудовлетворительно"
    else -> "несуществующая оценка $grade"
}
----

Эта функция принимает на вход целочисленную оценку (grade) и формирует на выходе соответствующую ей строку.
Напомним, что строкам в Котлине соответствует тип **String** и записываются они в двойных кавычках.

Для проверки возможного значения **grade** мы используем конструкцию **when (grade)**,
в которой оно последовательно сравнивается с 5, 4, 3 и 2.
Обратите внимание, что в нашей записи **when** имеется и пятый случай (else).
Его присутствие необходимо, так как функция должна знать, какой результат ей следует вернуть на выход,
для любого допустимого значения входа (в данном случае это тип **Int** с его диапазоном допустимых значений).
Строго говоря, ветка **else** здесь соответствует ошибочной ситуации,
которая может предусматривать специальную обработку -- но об этом позже.
В функции **gradeNotation** в этой ситуации мы формируем строку "несуществующая оценка",
дописывая к ней значение переданной оценки, например: "несуществующая оценка 0".

Рассмотрим теперь более сложный случай. Пусть нам необходимо написать функцию,
рассчитывающую минимальный из имеющихся корней биквадратного уравнения: ax^4^ + bx^2^ + c = 0.
Попробуем сначала записать алгоритм решения задачи в виде последовательности действий:

 1. Если a равно 0, уравнение вырождается в bx^2^ + c = 0. Вырожденное уравнение имеет решение при отрицательном c / b.
 1. Рассчитаем дискриминант d = b^2^ - 4ac.
 1. Если d меньше 0, у уравнения нет решений.
 1. В противном случае рассчитаем x1 = (-b + sqrt(d))/(2a) и x2 = (-b - sqrt(d))/(2a).
 1. Найдём x3 = Max(x1, x2).
 1. Если x3 < 0, у нашего уравнения нет решений.
 1. В противном случае минимальное решение это -sqrt(x3).

Запишем теперь то же самое на Котлине. Для обозначения ситуации, когда решений нет, будем использовать
специальную константу `Double.NaN`, так называемое не-число.
На практике она может получиться как результат некоторых некорректных действий с вещественными числами,
например, после вычисления квадратного корня из -1.

[source,kotlin]
----
fun minBiRoot(a: Double, b: Double, c: Double) {
    if (a == 0.0) {
        if (b == 0.0) return Double.NaN
        val bc = -c / b
        return if (bc < 0.0) Double.NaN else -Math.sqrt(bc)
    }
    val d = discriminant(a, b, c)
    if (d < 0.0) return Double.NaN
    val x1 = (-b + Math.sqrt(d)) / (2 * a)
    val x2 = (-b - Math.sqrt(d)) / (2 * a)
    val x3 = Math.max(x1, x2)
    return if (x3 < 0.0) Double.NaN else -Math.sqrt(x3)
}

Пояснения.

== Упражнения

Откройте файл `srс/lesson2/task1/IfElse.kt` в проекте `KotlinAsFirst`.
Выберите любую из задач в нём. Придумайте её решение и запишите его в теле соответствующей функции.
Откройте файл `test/lesson2/task1/Tests.kt`,
найдите в нём тестовую функцию -- её название должно совпадать с названием написанной вами функции.
Запустите тестирование, в случае обнаружения ошибок исправьте их и добейтесь прохождения теста.

Решите несколько других задач из того же файла, пока не убедитесь в том, что можете их решать уверенно
и без посторонней помощи. После этого вы можете перейти к следующему разделу.
