= 7. Классы и интерфейсы

В этом разделе мы плавно переходим от простых классов к более сложным.
На самом деле, прямого разграничения классов на "простые" и "сложные" не существует;
сложность класса приблизительно определяется количеством его свойств и функций.

С постепенным усложнением класса, его описание начинает увеличиваться в объёме.
Кроме этого, могут появиться несколько вариантов выполнения классом тех или иных действий.
Начиная с этого момента, есть смысл задуматься об отдельных ответах на вопросы "Что делает объект" и "Как он это делает".
В Котлине, ответ на первый вопрос дают __интерфейсы__ (**interface**), на второй -- __классы__ (**class**).

== Интерфейсы

Интерфейс определяет, что должен уметь делать объект.
С точки зрения Котлина, это набор свойств (с их типами) и функций (с их параметрами и результатом),
которые должны у этого объекта иметься.

Рассмотрим в качестве примера матрицу, то есть прямоугольную таблицу, имеющую M рядов и N колонок.
В совокупности, матрица имеет `M * N` ячеек, в каждой из которых хранится элемент матрицы определённого типа.
Будет считать, что типы всех элементов матрицы совпадают.
В этом случае, определение __интерфейса__ матрицы на Котлине может выглядеть так:

[source,kotlin]
----
data class Cell(val row: Int, val column: Int)

interface Matrix<E> {
    val height: Int
    val width: Int

    operator fun get(row: Int, column: Int): E
    operator fun get(cell: Cell): E

    operator fun set(row: Int, column: Int, value: E)
    operator fun set(cell: Cell, value: E)
}
----

Здесь `Cell` -- элементарный класс с данными для хранения координат (ряд, колонка) определённой ячейки матрицы.
Заголовок `interface Matrix<E>` определяет интерфейс с именем **Matrix**, использующий __настраиваемый тип__ `E`.
Никаких ограничений на этот тип не задано, поэтому он может быть произвольным.
В данном случае предполагается, что все элементы матрицы имеют тип `E`.

Свойства `height` и `width` определяют высоту (число рядов) и ширину (число колонок) матрицы.
Это целые числа, но значения их не заданы, поскольку интерфейс определяет лишь, **что** есть у матрицы.
Две операторных функции `get` предназначены для определения содержимого определённой ячейки матрицы
(для удобства, одна из них работает с двумя целочисленными параметрами, другая -- с одним параметром-ячейкой).
Результат обеих функций имеет тип `E` (поскольку элементы имеют этот тип), но **как** он определяется --
в интерфейсе опять-таки неизвестно.

Наконец, операторные функции `set` предназначены для замены содержимого определённой ячейки матрицы.
Их последний параметр содержит элемент, который нужно записать в заданную ячейку.
Результат у данных функций отсутствует, но они меняют внутреннее состояние матрицы, то есть имеют побочный эффект.
Вызывать `set` можно как непосредственно, так и с помощью индексации:
`matrix[cell] = value` эквивалентно `matrix.set(cell, value)`.
Как `get`, так и `set` предполагаеют, что номер ряда лежит в диапазоне `0..height - 1`,
а номер колонки в диапазоне `0..width - 1`.

Интерфейсы определяют новый тип или множество типов -- в данном случае `Matrix<E>` -- но не имеют конструкторов.
Имея только интерфейс, создать объект данного типа нельзя.
Тем не менее, имея только интерфейс, можно определять различные операции над уже имеющимся объектом.
Например, следующая функция меняет знак всех элементов целочисленной матрицы на обратный:

[source,kotlin]
----
fun invertMatrix(matrix: Matrix<Int>) {
    for (row in 0..matrix.height - 1) {
        for (column in 0..matrix.width - 1) {
            matrix[row, column] = -matrix[row, column]
        }
    }
}
----

Заметьте, что здесь мы ничего не знаем о внутреннем устройстве матрицы и никак не используем информацию о нём.
Сам код достаточно тривиален и не требует особых объяснений.
Оператор `matrix[row, column] = -matrix[row, column` использует сразу обе операторные функции `get`, `set`
и эквивалентен следующему: `matrix.set(row, column, -matrix.get(row, column))`.

Таким образом, интерфейсы позволяют описывать операции обобщённо, не задумываясь о внутренностях того или иного объекта.
Кроме этого, интерфейсы -- удобное средство для описания спецификаций, они позволяют заранее договориться о том,
что можно будет делать с тем или иным объектом. По этим причинам, интерфейсы широко используются в программировании.

Неискушённого читателя это может удивить, но типы `List<T>` и `MutableList<T>`, так же, как и
`Set<T>`, `MutableSet<T>`, `Collection<T>`, `MutableCollection<T>` -- все являются интерфейсами.
В описании списков ничего не говорится о том, как именно эти списки работают.
Например, существует две широко известные __реализации__ интерфейса `MutableList<T>` --
а именно, `ArrayList<T>` (список, реализованный на основе массива, в котором все элементы хранятся единым куском),
и `LinkedList<T>` (так называемый __связанный__ список, в котором каждый элемент содержит ссылку на следующий
и на предыдущий, при этом хранятся все элементы отдельно).
Но, имея `List<T>`, мы не знаем, с какой конкретно из этих двух реализаций мы имеем дело.

== Функции-создатели

Функции-создатели в некотором смысле являются заменой конструкторам.
Они предназначены для создания объекта, реализующего тот или иной интерфейс;
при этом, естественно, для их написания должна существовать реализация данного интерфейса
и функция-создатель обычно вызывает внутри себя тот или иной конструктор,
иногда делая выбор из нескольких вариантов.
Известными примерами функций-создателей являются `listOf(...)`, `mutableListOf(...)`, `setOf(...)`, `mutableSetOf(...)`.
Для матрицы, подобная функция может быть определена так:

[source,kotlin]
----
fun <E> createMatrix(height: Int, width: Int, e: E): Matrix<E> = TODO()
----

Здесь `fun <E>` говорит о том, что функция использует настраиваемый тип `E` -- тип элементов матрицы.
Первый и второй параметр задают высоту и ширину матрицы,
а третий -- значение элемента, который при создании матрицы будет записан во все ячейки.
Результатом функции должна стать вновь созданная матрица, но,
поскольку реализации интерфейса `Matrix<E>` ещё нет, вместо вызова конструктора в теле фигурирует `TODO()` --
специальная функция, бросающая исключение `UnsupportedOperationException`.

Имея функцию-создатель, мы можем описывать более сложные операции с матрицами,
которые не только изменяют существующие матрицы, но и создают новые -- по-прежнему не зная ничего о реализации.
Например, транспонирование меняет местами ряды и колонки в матрице:

[source,kotlin]
----
fun <E> transpose(matrix: Matrix<E>): Matrix<E> {
    if (matrix.width < 1 || matrix.height < 1) return matrix
    val result = createMatrix(height = matrix.width, width = matrix.height, e = matrix[0, 0])
    for (i in 0..matrix.width - 1) {
        for (j in 0..matrix.height - 1) {
            result[i, j] = matrix[j, i]
        }
    }
    return result
}
----

Так мы создаём новую матрицу, меняя местами ширину и высоту старой,
а затем в цикле переписываем элементы из старой матрицы в новую -- с учётом того, что ряды стали колонками и наоборот.

При попытке протестировать эту функцию мы получим исключение `UnsupportedOperationException`
при создании матрицы -- до тех пор, пока не сделаем её реализацию и не используем её в функции-создателе.

== Класс как реализация интерфейса

== Упражнения

Откройте файл `srс/lesson7/task1/Matrix.kt` в проекте `KotlinAsFirst`.
Он содержит определение интерфейса `Matrix<E>`, функции-создателя `createMatrix` и реализации `MatrixImpl<E>`.
Выберите один из рассмотренных выше вариантов реализаций матрицы и напишите определения ВСЕХ функций
в классе `MatrixImpl`, после чего напишите определение функции-создателя.
Протестируйте свою реализацию, используя тесты из `test/lesson7/task1/Tests.kt`.

Откройте теперь файл `srс/lesson6/task2/Matrices.kt`.
Файл содержит задачи на различные операции с матрицами, все они используют готовый интерфейс `Matrix<E>`.
С использованием данного интерфейса и функции-создателя, решите одну или несколько задач из этого файла.
Протестируйте свою реализацию, используя тесты из `test/lesson7/task2/Tests.kt`.
Многие задачи из этого файла сложны, особенно это касается двух последних задач про "Игру в 15".

Переходите к разделу 8.
